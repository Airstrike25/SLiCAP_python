

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>SLiCAPmath.py &mdash; SLiCAP Programming 1.0.2020 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="_static/myStyle.css" type="text/css" />
  

  
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="SLiCAP Programming 1.0.2020 documentation" href="index.html"/>
        <link rel="up" title="SLiCAP Reference" href="SLiCAPreference.html"/>
        <link rel="next" title="SLiCAPlex.py" href="SLiCAPlex.html"/>
        <link rel="prev" title="SLiCAPprotos.py" href="SLiCAPprotos.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="slicap-programming.html" class="icon icon-home"> SLiCAP Programming
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">SLiCAP open-source</a></li>
<li class="toctree-l1"><a class="reference internal" href="ToDo.html">ToDo</a></li>
<li class="toctree-l1"><a class="reference internal" href="configure.html">SLiCAP configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="math.html">SLiCAP math library</a></li>
<li class="toctree-l1"><a class="reference internal" href="matrices.html">Building the MNA matrices</a></li>
<li class="toctree-l1"><a class="reference internal" href="pythonMaximaInterface.html">Python-Maxima interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="html.html">HTML reports</a></li>
<li class="toctree-l1"><a class="reference internal" href="Parser.html">SLiCAP netlist parser</a></li>
<li class="toctree-l1"><a class="reference internal" href="parsingMethod.html">Parsing method</a></li>
<li class="toctree-l1"><a class="reference internal" href="modelParams.html">Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="subCircuits.html">Sub circuits</a></li>
<li class="toctree-l1"><a class="reference internal" href="library.html">SLiCAP Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="execute.html">Execute</a></li>
<li class="toctree-l1"><a class="reference internal" href="plot.html">Plotting</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="SLiCAPreference.html">SLiCAP Reference</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="SLiCAP.html">SLiCAP.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="SLiCAPinstruction.html">SLiCAPinstruction.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="SLiCAPexecute.html">SLiCAPexecute.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="SLiCAPyacc.html">SLiCAPyacc.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="SLiCAPhtml.html">SLiCAPhtml.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="SLiCAPplots.html">SLiCAPplots.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="SLiCAPpythonMaxima.html">SLiCAPpythonMaxima.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="SLiCAPmatrices.html">SLiCAPmatrices.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="SLiCAPprotos.html">SLiCAPprotos.py</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">SLiCAPmath.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="SLiCAPlex.html">SLiCAPlex.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="SLiCAPini.html">SLiCAPini.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="SLiCAPconfig.html">SLiCAPconfig.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="SLiCAPnotebook.html">SLiCAPnotebook.py</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="slicap-programming.html">SLiCAP Programming</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="slicap-programming.html">Docs</a> &raquo;</li>
        
          <li><a href="SLiCAPreference.html">SLiCAP Reference</a> &raquo;</li>
        
      <li>SLiCAPmath.py</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/SLiCAPmath.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-SLiCAPmath">
<span id="slicapmath-py"></span><h1>SLiCAPmath.py<a class="headerlink" href="#module-SLiCAPmath" title="Permalink to this headline">¶</a></h1>
<p>SLiCAP module with extended matrix class and SLiCAP math functions.</p>
<p>Imported by the module <strong>SLiCAPprotos.py</strong>.</p>
<dl class="function">
<dt id="SLiCAPmath.assumePosParams">
<code class="descclassname">SLiCAPmath.</code><code class="descname">assumePosParams</code><span class="sig-paren">(</span><em>expr</em>, <em>params='all'</em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAPmath.assumePosParams" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the sympy expression ‘expr’ in which parameters have
been redefined as positive.</p>
</dd></dl>

<dl class="function">
<dt id="SLiCAPmath.assumeRealParams">
<code class="descclassname">SLiCAPmath.</code><code class="descname">assumeRealParams</code><span class="sig-paren">(</span><em>expr</em>, <em>params='all'</em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAPmath.assumeRealParams" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the sympy expression ‘expr’ in which parameters have
been redefined as real.</p>
</dd></dl>

<dl class="function">
<dt id="SLiCAPmath.cancelPZ">
<code class="descclassname">SLiCAPmath.</code><code class="descname">cancelPZ</code><span class="sig-paren">(</span><em>poles</em>, <em>zeros</em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAPmath.cancelPZ" title="Permalink to this definition">¶</a></dt>
<dd><p>Cancels poles and zeros that coincide within the displayed accuracy.</p>
</dd></dl>

<dl class="function">
<dt id="SLiCAPmath.checkNumber">
<code class="descclassname">SLiCAPmath.</code><code class="descname">checkNumber</code><span class="sig-paren">(</span><em>var</em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAPmath.checkNumber" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a number with its value represented by var, or None if var
does not represent a number.</p>
</dd></dl>

<dl class="function">
<dt id="SLiCAPmath.coeffsTransfer">
<code class="descclassname">SLiCAPmath.</code><code class="descname">coeffsTransfer</code><span class="sig-paren">(</span><em>LaplaceRational</em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAPmath.coeffsTransfer" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a nested list with the coefficients of the Laplace variable of the 
numerator and of the denominator of LpalaceRational.
The coefficients are in ascending order.
ToDo:</p>
<blockquote>
<div>Factorization and simplification according to ini settings</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="SLiCAPmath.dBmagFunc_f">
<code class="descclassname">SLiCAPmath.</code><code class="descname">dBmagFunc_f</code><span class="sig-paren">(</span><em>LaplaceExpr</em>, <em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAPmath.dBmagFunc_f" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the dB magnitude at the real frequency f (Fourier) from the 
Laplace function ‘LaplaceExpr’. The only symbolic variable in this function 
should be the Laplace variable: ini.Laplace.</p>
<p>If ini.Hz == true, the Laplace variable will be replaced with 
2*sp.pi*sp.I*ini.frequency.</p>
<p>If ini.Hz == False, the Laplace variable will be replaced with 
sp.I*ini.frequency.</p>
<p>After the Fouriers Transform has been obtained from the Laplace Transform,
the maginitudes at the desired frequenc(y)(ies) f will be calculated.</p>
<p>Input:</p>
<blockquote>
<div><ul class="simple">
<li>LaplaceExpr: a sympy expression of one variable (ini.frequency)</li>
<li><dl class="first docutils">
<dt>f <span class="classifier-delimiter">:</span> <span class="classifier">a numeric value, a list of numeric values or a </span></dt>
<dd>numpy array</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>Return variable:</p>
<blockquote>
<div><ul class="simple">
<li>a single value or a numpy array</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="SLiCAPmath.delayFunc_f">
<code class="descclassname">SLiCAPmath.</code><code class="descname">delayFunc_f</code><span class="sig-paren">(</span><em>LaplaceExpr</em>, <em>f</em>, <em>delta=0.0001</em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAPmath.delayFunc_f" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the group delay at the real frequency f (Fourier) from the 
Laplace function ‘LaplaceExpr’. The only symbolic variable in this function 
should be the Laplace variable: ini.Laplace.</p>
<p>If ini.Hz == true, the Laplace variable will be replaced with 
2*sp.pi*sp.I*ini.frequency.</p>
<p>If ini.Hz == False, the Laplace variable will be replaced with 
sp.I*ini.frequency.</p>
<p>After the Fouriers Transform has been obtained from the Laplace Transform,
the maginitudes at the desired frequenc(y)(ies) f will be calculated.</p>
<p>Input:</p>
<blockquote>
<div><ul class="simple">
<li>LaplaceExpr: a sympy expression of one variable (ini.frequency)</li>
<li><dl class="first docutils">
<dt>f <span class="classifier-delimiter">:</span> <span class="classifier">a numeric value, a list of numeric values or a </span></dt>
<dd>numpy array</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>Return variable:</p>
<blockquote>
<div><ul class="simple">
<li>a single value or a numpy array</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="SLiCAPmath.findServoBandwidth">
<code class="descclassname">SLiCAPmath.</code><code class="descname">findServoBandwidth</code><span class="sig-paren">(</span><em>loopgainRational</em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAPmath.findServoBandwidth" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines the intersection points of the asymptotes of the magnitude of
the loopgain with unity. It returns a dictionary with key-value pairs:</p>
<blockquote>
<div><ul class="simple">
<li>hpf: frequency of high-pass intersection</li>
<li>hpo: order at high-pass intersection</li>
<li>lpf: frequency of low-pass intersection</li>
<li>lpo: order at low-pass intersection</li>
<li>mbv: mid-band value of the loopgain (highest value at order = zero)</li>
<li>mbf: lowest freqency of mbv</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="SLiCAPmath.fullSubs">
<code class="descclassname">SLiCAPmath.</code><code class="descname">fullSubs</code><span class="sig-paren">(</span><em>valExpr</em>, <em>parDefs</em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAPmath.fullSubs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the valExpr after all parameters of parDefs have been substituted
recursively into valExpr.
parDefs is a dictionary in which the keys are sympy symbols. The type of 
the value fields may be any sympy type, integer or float.</p>
</dd></dl>

<dl class="function">
<dt id="SLiCAPmath.invLaplace">
<code class="descclassname">SLiCAPmath.</code><code class="descname">invLaplace</code><span class="sig-paren">(</span><em>numer</em>, <em>denom</em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAPmath.invLaplace" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the Inverse Laplace Transform of a numerical rational expression
of which the sympy polynomials of the numerator and the denominator are 
passed as arguments, respecively.</p>
<p>ToDo: This function is not used because of observed problems with residues
at dominant pole-zero pairs. Instead maxILT() is used, which also supports
symbolic inverse Laplace.</p>
</dd></dl>

<dl class="function">
<dt id="SLiCAPmath.magFunc_f">
<code class="descclassname">SLiCAPmath.</code><code class="descname">magFunc_f</code><span class="sig-paren">(</span><em>LaplaceExpr</em>, <em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAPmath.magFunc_f" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the magnitude at the real frequency f (Fourier) from the 
Laplace function ‘LaplaceExpr’. The only symbolic variable in this function 
should be the Laplace variable: ini.Laplace.</p>
<p>If ini.Hz == true, the Laplace variable will be replaced with 
2*sp.pi*sp.I*ini.frequency.</p>
<p>If ini.Hz == False, the Laplace variable will be replaced with 
sp.I*ini.frequency.</p>
<p>After the Fouriers Transform has been obtained from the Laplace Transform,
the maginitudes at the desired frequenc(y)(ies) f will be calculated.</p>
<p>Input:</p>
<blockquote>
<div><ul class="simple">
<li>LaplaceExpr: a sympy expression of one variable (ini.frequency)</li>
<li><dl class="first docutils">
<dt>f <span class="classifier-delimiter">:</span> <span class="classifier">a numeric value, a list of numeric values or a </span></dt>
<dd>numpy array</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>Return variable:</p>
<blockquote>
<div><ul class="simple">
<li>a single value or a numpy array</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="SLiCAPmath.mag_f">
<code class="descclassname">SLiCAPmath.</code><code class="descname">mag_f</code><span class="sig-paren">(</span><em>LaplaceExpr</em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAPmath.mag_f" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the magnitude as a function of the real frequency f (Fourier) 
from the Laplace function ‘LaplaceExpr’.</p>
<p>If ini.Hz == true, the Laplace variable will be replaced with 
2*sp.pi*sp.I*ini.frequency.</p>
<p>If ini.Hz == False, the Laplace variable will be replaced with 
sp.I*ini.frequency.</p>
<p>Input:</p>
<blockquote>
<div><ul class="simple">
<li>LaplaceExpr: a sympy expression of one variable (ini.frequency)</li>
<li><dl class="first docutils">
<dt>f <span class="classifier-delimiter">:</span> <span class="classifier">a numeric value, a list of numeric values or a </span></dt>
<dd>numpy array</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>Return variable:</p>
<blockquote>
<div><ul class="simple">
<li>a sympy expression representing the magnitude of the Fourier 
Transform.</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="SLiCAPmath.makeLaplaceRational">
<code class="descclassname">SLiCAPmath.</code><code class="descname">makeLaplaceRational</code><span class="sig-paren">(</span><em>gain</em>, <em>zeros</em>, <em>poles</em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAPmath.makeLaplaceRational" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a Laplace rational from a gain factor, a list of zeros and a list
of poles:</p>
<blockquote>
<div>F(s) = gain * product_j(s-z_j) / product_i(s-p_i)</div></blockquote>
<p>Terms with complex conjugated poles or zeros will be combined into 
quadratic terms.</p>
<p>The gain factor should be taken as the ratio of the coefficients of the 
highest order of the Laplace variable of the numerator and the denominator:
this is not the DC gain!</p>
</dd></dl>

<dl class="class">
<dt id="SLiCAPmath.matrix">
<em class="property">class </em><code class="descclassname">SLiCAPmath.</code><code class="descname">matrix</code><span class="sig-paren">(</span><em>M</em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAPmath.matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>SLiCAP matrix class for symbolic calculations.</p>
<p>This class is an extension to the sympy Matrix class. It calculates
determinants using minor expansion
return types for matrices are &lt;class ‘sympy.matrices.matrices.Matrix’&gt;.</p>
<p>Determination of determinants is slow. SLiCAP uses Maxima CAS for this
purpose.</p>
<p>Adapted from: from “Bill McNeill &lt;<a class="reference external" href="mailto:billmcn&#37;&#52;&#48;speakeasy&#46;net">billmcn<span>&#64;</span>speakeasy<span>&#46;</span>net</a>&gt;”</p>
<dl class="method">
<dt id="SLiCAPmath.matrix.Cramer">
<code class="descname">Cramer</code><span class="sig-paren">(</span><em>colVector</em>, <em>colNumber</em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAPmath.matrix.Cramer" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns matrix with colVector substituted in column colNumber</p>
</dd></dl>

<dl class="method">
<dt id="SLiCAPmath.matrix.adjugate">
<code class="descname">adjugate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAPmath.matrix.adjugate" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns adjugate matrix of M</p>
</dd></dl>

<dl class="method">
<dt id="SLiCAPmath.matrix.coFactor">
<code class="descname">coFactor</code><span class="sig-paren">(</span><em>i</em>, <em>j</em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAPmath.matrix.coFactor" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns cofactor C(i,j)</p>
</dd></dl>

<dl class="method">
<dt id="SLiCAPmath.matrix.coFactorMatrix">
<code class="descname">coFactorMatrix</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAPmath.matrix.coFactorMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns cofactor matrix of M</p>
</dd></dl>

<dl class="method">
<dt id="SLiCAPmath.matrix.determinant">
<code class="descname">determinant</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAPmath.matrix.determinant" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns determinant calculated by expansion of minors.
No multiplication with zero speeds up calculation for sparse matrices.</p>
</dd></dl>

<dl class="method">
<dt id="SLiCAPmath.matrix.dot">
<code class="descname">dot</code><span class="sig-paren">(</span><em>M2</em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAPmath.matrix.dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns product of two matrices M1 and M2</p>
</dd></dl>

<dl class="method">
<dt id="SLiCAPmath.matrix.dotV">
<code class="descname">dotV</code><span class="sig-paren">(</span><em>Vr</em>, <em>Vc</em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAPmath.matrix.dotV" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns inner product of row vector Vr and column vector Vc.
No multiplications with zero or +/- unity.</p>
</dd></dl>

<dl class="method">
<dt id="SLiCAPmath.matrix.expandByMinors">
<code class="descname">expandByMinors</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAPmath.matrix.expandByMinors" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates determinant by expansion of minors.
No multiplications with zero.</p>
</dd></dl>

<dl class="method">
<dt id="SLiCAPmath.matrix.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAPmath.matrix.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns inverse matrix of M
return self.adjugate()/self.determinant()</p>
</dd></dl>

<dl class="method">
<dt id="SLiCAPmath.matrix.minor">
<code class="descname">minor</code><span class="sig-paren">(</span><em>i</em>, <em>j</em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAPmath.matrix.minor" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns determinant of M after deleting row i and column j</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="SLiCAPmath.normalizeLaplaceRational">
<code class="descclassname">SLiCAPmath.</code><code class="descname">normalizeLaplaceRational</code><span class="sig-paren">(</span><em>LaplaceRational</em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAPmath.normalizeLaplaceRational" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalizes a Laplace rational:</p>
<blockquote>
<div><p>F(s) = gain * s^l (1+b_1*s + … + b_m*s^m)/ (1+a_1*s + … + a_n*s^n)</p>
<p>with l zero if there is a finite nonzero zero-frequency value, else
positive or negative</p>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="SLiCAPmath.numRoots">
<code class="descclassname">SLiCAPmath.</code><code class="descname">numRoots</code><span class="sig-paren">(</span><em>expr</em>, <em>var</em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAPmath.numRoots" title="Permalink to this definition">¶</a></dt>
<dd><p>Using numpy for calculation of numeric roots is about 60 times faster than 
using sympy.roots(expr, var)
numpy.roots:</p>
<blockquote>
<div><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.polyroots.html">https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.polynomial.polyroots.html</a>
The root estimates are obtained as the eigenvalues of the companion matrix.
Roots far from the origin of the complex plane may have large errors due to 
the numerical instability of the power series for such values. Roots with 
multiplicity greater than 1 will also show larger errors as the value of 
the series near such points is relatively insensitive to errors in the roots. 
Isolated roots near the origin can be improved by a few iterations of 
Newton’s method.</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="SLiCAPmath.phaseFunc_f">
<code class="descclassname">SLiCAPmath.</code><code class="descname">phaseFunc_f</code><span class="sig-paren">(</span><em>LaplaceExpr</em>, <em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAPmath.phaseFunc_f" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the phase angle at the real frequency f (Fourier) from the 
Laplace function ‘LaplaceExpr’. The only symbolic variable in this function 
should be the Laplace variable: ini.Laplace.</p>
<p>If ini.Hz == true, the Laplace variable will be replaced with 
2*sp.pi*sp.I*ini.frequency.</p>
<p>If ini.Hz == False, the Laplace variable will be replaced with 
sp.I*ini.frequency.</p>
<p>After the Fouriers Transform has been obtained from the Laplace Transform,
the maginitudes at the desired frequenc(y)(ies) f will be calculated.</p>
<p>Input:</p>
<blockquote>
<div><ul class="simple">
<li>LaplaceExpr: a sympy expression of one variable (ini.frequency)</li>
<li><dl class="first docutils">
<dt>f <span class="classifier-delimiter">:</span> <span class="classifier">a numeric value, a list of numeric values or a </span></dt>
<dd>numpy array</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>Return variable:</p>
<blockquote>
<div><ul class="simple">
<li>a single value or a numpy array</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="SLiCAPmath.phaseMargin">
<code class="descclassname">SLiCAPmath.</code><code class="descname">phaseMargin</code><span class="sig-paren">(</span><em>LaplaceExpr</em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAPmath.phaseMargin" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the phase margin assuming the loop gain definition according to 
the asymptotic gain model.</p>
</dd></dl>

<dl class="function">
<dt id="SLiCAPmath.phase_f">
<code class="descclassname">SLiCAPmath.</code><code class="descname">phase_f</code><span class="sig-paren">(</span><em>LaplaceExpr</em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAPmath.phase_f" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the magnitude as a function of the real frequency f (Fourier) 
from the Laplace function ‘LaplaceExpr’.</p>
<p>If ini.Hz == true, the Laplace variable will be replaced with 
2*sp.pi*sp.I*ini.frequency.</p>
<p>If ini.Hz == False, the Laplace variable will be replaced with 
sp.I*ini.frequency.</p>
<p>Input:</p>
<blockquote>
<div><ul class="simple">
<li>LaplaceExpr: a sympy expression of one variable (ini.frequency)</li>
<li><dl class="first docutils">
<dt>f <span class="classifier-delimiter">:</span> <span class="classifier">a numeric value, a list of numeric values or a </span></dt>
<dd>numpy array</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>Return variable:</p>
<blockquote>
<div><ul class="simple">
<li>a sympy expression representing the phase of the Fourier Transform.</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="SLiCAPmath.polyCoeffs">
<code class="descclassname">SLiCAPmath.</code><code class="descname">polyCoeffs</code><span class="sig-paren">(</span><em>expr</em>, <em>var</em><span class="sig-paren">)</span><a class="headerlink" href="#SLiCAPmath.polyCoeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list with coefficients of ‘var’ in descending order.</p>
</dd></dl>

</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="SLiCAPlex.html" class="btn btn-neutral float-right" title="SLiCAPlex.py" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="SLiCAPprotos.html" class="btn btn-neutral" title="SLiCAPprotos.py" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, SLiCAP development team.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.0.2020',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>